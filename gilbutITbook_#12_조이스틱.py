def solution(name):
    """
    [문제 요약]
    - 처음 모든 문자가 'A'인 상태에서 주어진 name을 만들어야 한다.
    - ▲: 알파벳을 위로 변경, ▼: 아래로 변경
    - ◀: 커서를 왼쪽으로 이동, ▶: 커서를 오른쪽으로 이동
    - 최소 조작 횟수를 구하는 문제.

    [풀이 전략]
    1. 알파벳 하나하나를 'A'에서 목표 문자로 바꾸기 위해 필요한 ▲▼ 조작 수를 계산해 더한다.
        - 위로 가는 횟수와 아래로 가는 횟수 중 더 작은 쪽을 선택한다.
    
    2. 커서 이동 최적화를 위해 여러 이동 경로를 비교한다.
        - 기본적으로 오른쪽으로 끝까지 가는 이동(n-1)을 가정한다.
        - 그러나 중간에 'A'가 연속된 구간이 있다면, 돌아가거나 우회하는 것이 더 짧을 수 있다.
        - 왼쪽으로 돌아가는 경우(i * 2 + n - next_i), 
          오른쪽으로 돌아가는 경우((n - next_i) * 2 + i)까지 고려해 가장 짧은 이동 경로를 선택한다.
    
    최종적으로 알파벳 조작 수와 커서 이동 수를 합쳐 최소 조작 횟수를 반환한다.
    """

    answer = 0  # 총 조이스틱 조작 횟수
    n = len(name)  # 이름의 길이
    
    # 1. 알파벳 맞추기 (▲▼)
    for char in name:
        # 위로 가는 경우, 아래로 가는 경우 중 더 적은 조작 수를 선택
        move = min(ord(char) - ord('A'), 26 - (ord(char) - ord('A')))
        answer += move  # 해당 글자를 A에서 원하는 문자로 바꾸는 데 드는 조작 수 합산
    
    # 2. 커서 움직이기 (◀▶)
    move = n - 1  # 기본 이동은 "오른쪽으로 쭉 가는 것" (n-1번 이동)
    
    for i in range(n):
        next_i = i + 1  # 다음 위치
        # 다음 위치부터 연속된 'A'를 모두 건너뜀
        while next_i < n and name[next_i] == 'A':
            next_i += 1
        
        # (1) 현재 위치까지 갔다가 돌아간 후 끝까지 가는 경우
        left_turn = i * 2 + n - next_i
        
        # (2) 끝까지 갔다가 돌아와서 현재 위치까지 오는 경우
        right_turn = (n - next_i) * 2 + i
        
        # 이동 방법 중 최소값을 갱신
        move = min(move, left_turn, right_turn)
    
    # 알파벳 맞추는 조작 수 + 커서 이동 조작 수
    answer += move
    return answer
